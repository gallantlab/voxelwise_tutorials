
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "_auto_examples/shortclips/06_plot_banded_ridge_model.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download__auto_examples_shortclips_06_plot_banded_ridge_model.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr__auto_examples_shortclips_06_plot_banded_ridge_model.py:


=====================================================================
Fit a banded ridge model with both wordnet and motion energy features
=====================================================================

In this example, we model the fMRI responses with a `banded ridge regression`,
with two different feature spaces: motion energy and wordnet categories.

*Banded ridge regression:* Since the relative scaling of both feature spaces is
unknown, we use two regularization hyperparameters (one per feature space) in a
model called banded ridge regression [1]_. Just like with ridge regression, we
optimize the hyperparameters over cross-validation. An efficient implementation
of this model is available in the `himalaya
<https://github.com/gallantlab/himalaya>`_ package.

*Running time:* This example is more computationally intensive than the
previous examples. With a GPU backend, model fitting takes around 6 minutes.
With a CPU backend, it can last 10 times more.

.. GENERATED FROM PYTHON SOURCE LINES 20-20

.. code-block:: default








.. GENERATED FROM PYTHON SOURCE LINES 22-24

Path of the data directory
--------------------------

.. GENERATED FROM PYTHON SOURCE LINES 24-28

.. code-block:: default

    from voxelwise_tutorials.io import get_data_home
    directory = get_data_home(dataset="shortclips")
    print(directory)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/jlg/tomdlt/voxelwise_tutorials_data/shortclips




.. GENERATED FROM PYTHON SOURCE LINES 29-33

.. code-block:: default


    # modify to use another subject
    subject = "S01"








.. GENERATED FROM PYTHON SOURCE LINES 34-39

Load the data
-------------

As in the previous examples, we first load the fMRI responses, which are our
regression targets.

.. GENERATED FROM PYTHON SOURCE LINES 39-50

.. code-block:: default

    import os
    import numpy as np
    from voxelwise_tutorials.io import load_hdf5_array

    file_name = os.path.join(directory, "responses", f"{subject}_responses.hdf")
    Y_train = load_hdf5_array(file_name, key="Y_train")
    Y_test = load_hdf5_array(file_name, key="Y_test")

    print("(n_samples_train, n_voxels) =", Y_train.shape)
    print("(n_repeats, n_samples_test, n_voxels) =", Y_test.shape)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (n_samples_train, n_voxels) = (3600, 84038)
    (n_repeats, n_samples_test, n_voxels) = (10, 270, 84038)




.. GENERATED FROM PYTHON SOURCE LINES 51-53

We also compute the explainable variance, to exclude voxels with low
explainable variance from the fit, and speed up the model fitting.

.. GENERATED FROM PYTHON SOURCE LINES 53-61

.. code-block:: default


    from voxelwise_tutorials.utils import explainable_variance
    ev = explainable_variance(Y_test)
    print("(n_voxels,) =", ev.shape)

    mask = ev > 0.1
    print("(n_voxels_mask,) =", ev[mask].shape)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (n_voxels,) = (84038,)
    (n_voxels_mask,) = (6849,)




.. GENERATED FROM PYTHON SOURCE LINES 62-64

We average the test repeats, to remove the non-repeatable part of fMRI
responses.

.. GENERATED FROM PYTHON SOURCE LINES 64-68

.. code-block:: default

    Y_test = Y_test.mean(0)

    print("(n_samples_test, n_voxels) =", Y_test.shape)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (n_samples_test, n_voxels) = (270, 84038)




.. GENERATED FROM PYTHON SOURCE LINES 69-70

We fill potential NaN (not-a-number) values with zeros.

.. GENERATED FROM PYTHON SOURCE LINES 70-73

.. code-block:: default

    Y_train = np.nan_to_num(Y_train)
    Y_test = np.nan_to_num(Y_test)








.. GENERATED FROM PYTHON SOURCE LINES 74-75

And we make sure the targets are centered.

.. GENERATED FROM PYTHON SOURCE LINES 75-78

.. code-block:: default

    Y_train -= Y_train.mean(0)
    Y_test -= Y_test.mean(0)








.. GENERATED FROM PYTHON SOURCE LINES 79-81

Then we load both feature spaces, that are going to be used for the
linear regression model.

.. GENERATED FROM PYTHON SOURCE LINES 81-104

.. code-block:: default


    feature_names = ["wordnet", "motion_energy"]

    Xs_train = []
    Xs_test = []
    n_features_list = []
    for feature_space in feature_names:
        file_name = os.path.join(directory, "features", f"{feature_space}.hdf")
        Xi_train = load_hdf5_array(file_name, key="X_train")
        Xi_test = load_hdf5_array(file_name, key="X_test")

        Xs_train.append(Xi_train.astype(dtype="float32"))
        Xs_test.append(Xi_test.astype(dtype="float32"))
        n_features_list.append(Xi_train.shape[1])

    # concatenate the feature spaces
    X_train = np.concatenate(Xs_train, 1)
    X_test = np.concatenate(Xs_test, 1)

    print("(n_samples_train, n_features_total) =", X_train.shape)
    print("(n_samples_test, n_features_total) =", X_test.shape)
    print("[n_features_wordnet, n_features_motion_energy] =", n_features_list)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (n_samples_train, n_features_total) = (3600, 8260)
    (n_samples_test, n_features_total) = (270, 8260)
    [n_features_wordnet, n_features_motion_energy] = [1705, 6555]




.. GENERATED FROM PYTHON SOURCE LINES 105-109

Define the cross-validation scheme
----------------------------------

We define again a leave-one-run-out cross-validation split scheme.

.. GENERATED FROM PYTHON SOURCE LINES 109-117

.. code-block:: default


    from sklearn.model_selection import check_cv
    from voxelwise_tutorials.utils import generate_leave_one_run_out

    # indice of first sample of each run
    run_onsets = load_hdf5_array(file_name, key="run_onsets")
    print(run_onsets)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [   0  300  600  900 1200 1500 1800 2100 2400 2700 3000 3300]




.. GENERATED FROM PYTHON SOURCE LINES 118-119

We define a cross-validation splitter, compatible with ``scikit-learn`` API.

.. GENERATED FROM PYTHON SOURCE LINES 119-123

.. code-block:: default

    n_samples_train = X_train.shape[0]
    cv = generate_leave_one_run_out(n_samples_train, run_onsets)
    cv = check_cv(cv)  # copy the cross-validation splitter into a reusable list








.. GENERATED FROM PYTHON SOURCE LINES 124-130

Define the model
----------------

The model pipeline contains similar steps than the pipeline from previous
examples. We remove the mean of each feature with a ``StandardScaler``,
and add delays with a ``Delayer``.

.. GENERATED FROM PYTHON SOURCE LINES 130-136

.. code-block:: default

    from sklearn.pipeline import make_pipeline
    from sklearn.preprocessing import StandardScaler
    from voxelwise_tutorials.delayer import Delayer
    from himalaya.backend import set_backend
    backend = set_backend("torch_cuda", on_error="warn")








.. GENERATED FROM PYTHON SOURCE LINES 137-147

To fit the banded ridge model, we use ``himalaya``'s
``MultipleKernelRidgeCV`` model, with a separate linear kernel per feature
space. Similarly to ``KernelRidgeCV``, the model optimizes the
hyperparameters over cross-validation. However, while ``KernelRidgeCV`` has
to optimize only one hyperparameter (``alpha``), ``MultipleKernelRidgeCV``
has to optimize ``m`` hyperparameters, where ``m`` is the number of feature
spaces (here ``m = 2``). To do so, the model implements two different
solvers, one using hyperparameter random search, and one using hyperparameter
gradient descent. For large number of targets, we recommend using the
random-search solver.

.. GENERATED FROM PYTHON SOURCE LINES 149-152

The class takes a number of common parameters during initialization, such as
``kernels``, or ``solver``. Since the solver parameters vary depending on the
solver used, they are passed as a ``solver_params`` dictionary.

.. GENERATED FROM PYTHON SOURCE LINES 152-163

.. code-block:: default


    from himalaya.kernel_ridge import MultipleKernelRidgeCV

    # Here we will use the "random_search" solver.
    solver = "random_search"

    # We can check its specific parameters in the function docstring:
    solver_function = MultipleKernelRidgeCV.ALL_SOLVERS[solver]
    print("Docstring of the function %s:" % solver_function.__name__)
    print(solver_function.__doc__)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Docstring of the function solve_multiple_kernel_ridge_random_search:
    Solve multiple kernel ridge regression using random search.

        Parameters
        ----------
        Ks : array of shape (n_kernels, n_samples, n_samples)
            Input kernels.
        Y : array of shape (n_samples, n_targets)
            Target data.
        n_iter : int, or array of shape (n_iter, n_kernels)
            Number of kernel weights combination to search.
            If an array is given, the solver uses it as the list of kernel weights
            to try, instead of sampling from a Dirichlet distribution. Examples:
              - `n_iter=np.eye(n_kernels)` implement a winner-take-all strategy
                over kernels.
              - `n_iter=np.ones((1, n_kernels))/n_kernels` solves a (standard)
                kernel ridge regression.
        concentration : float, or list of float
            Concentration parameters of the Dirichlet distribution.
            If a list, iteratively cycle through the list.
            Not used if n_iter is an array.
        alphas : float or array of shape (n_alphas, )
            Range of ridge regularization parameter.
        score_func : callable
            Function used to compute the score of predictions versus Y.
        cv : int or scikit-learn splitter
            Cross-validation splitter. If an int, KFold is used.
        fit_intercept : boolean
            Whether to fit an intercept. If False, Ks should be centered
            (see KernelCenterer), and Y must be zero-mean over samples.
            Only available if return_weights == 'dual'.
        return_weights : None, 'primal', or 'dual'
            Whether to refit on the entire dataset and return the weights.
        Xs : array of shape (n_kernels, n_samples, n_features) or None
            Necessary if return_weights == 'primal'.
        local_alpha : bool
            If True, alphas are selected per target, else shared over all targets.
        jitter_alphas : bool
            If True, alphas range is slightly jittered for each gamma.
        random_state : int, or None
            Random generator seed. Use an int for deterministic search.
        n_targets_batch : int or None
            Size of the batch for over targets during cross-validation.
            Used for memory reasons. If None, uses all n_targets at once.
        n_targets_batch_refit : int or None
            Size of the batch for over targets during refit.
            Used for memory reasons. If None, uses all n_targets at once.
        n_alphas_batch : int or None
            Size of the batch for over alphas. Used for memory reasons.
            If None, uses all n_alphas at once.
        progress_bar : bool
            If True, display a progress bar over gammas.
        Ks_in_cpu : bool
            If True, keep Ks in CPU memory to limit GPU memory (slower).
            This feature is not available through the scikit-learn API.
        conservative : bool
            If True, when selecting the hyperparameter alpha, take the largest one
            that is less than one standard deviation away from the best.
            If False, take the best.
        Y_in_cpu : bool
            If True, keep the target values ``Y`` in CPU memory (slower).
        diagonalize_method : str in {"eigh", "svd"}
            Method used to diagonalize the kernel.
        return_alphas : bool
            If True, return the best alpha value for each target.

        Returns
        -------
        deltas : array of shape (n_kernels, n_targets)
            Best log kernel weights for each target.
        refit_weights : array or None
            Refit regression weights on the entire dataset, using selected best
            hyperparameters. Refit weights are always stored on CPU memory.
            If return_weights == 'primal', shape is (n_features, n_targets),
            if return_weights == 'dual', shape is (n_samples, n_targets),
            else, None.
        cv_scores : array of shape (n_iter, n_targets)
            Cross-validation scores per iteration, averaged over splits, for the
            best alpha. Cross-validation scores will always be on CPU memory.
        best_alphas : array of shape (n_targets, )
            Best alpha value per target. Only returned if return_alphas is True.
        intercept : array of shape (n_targets,)
            Intercept. Only returned when fit_intercept is True.
    




.. GENERATED FROM PYTHON SOURCE LINES 164-173

The hyperparameter random-search solver separates the hyperparameters into a
shared regularization ``alpha`` and a vector of positive kernel weights which
sum to one. This separation of hyperparameters allows to explore efficiently
a large grid of values for ``alpha`` for each sampled kernel weights vector.

We use *20* random-search iterations to have a reasonably fast example. To
have better results, especially for larger number of feature spaces, one
might need more iterations. (Note that there is currently no stopping
criterion in the random-search method.)

.. GENERATED FROM PYTHON SOURCE LINES 173-177

.. code-block:: default

    n_iter = 20

    alphas = np.logspace(1, 20, 20)








.. GENERATED FROM PYTHON SOURCE LINES 178-181

Batch parameters, used to reduce the necessary GPU memory. A larger value
will be a bit faster, but the solver might crash if it is out of memory.
Optimal values depend on the size of your dataset.

.. GENERATED FROM PYTHON SOURCE LINES 181-185

.. code-block:: default

    n_targets_batch = 200
    n_alphas_batch = 5
    n_targets_batch_refit = 200








.. GENERATED FROM PYTHON SOURCE LINES 186-188

We put all these parameters in a dictionary ``solver_params``, and define
the main estimator ``MultipleKernelRidgeCV``.

.. GENERATED FROM PYTHON SOURCE LINES 188-197

.. code-block:: default


    solver_params = dict(n_iter=n_iter, alphas=alphas,
                         n_targets_batch=n_targets_batch,
                         n_alphas_batch=n_alphas_batch,
                         n_targets_batch_refit=n_targets_batch_refit)

    mkr_model = MultipleKernelRidgeCV(kernels="precomputed", solver=solver,
                                      solver_params=solver_params, cv=cv)








.. GENERATED FROM PYTHON SOURCE LINES 198-206

We need a bit more work than in previous examples before defining the full
pipeline, since the banded ridge model requires `multiple` precomputed
kernels, one for each feature space. To compute them, we use the
``ColumnKernelizer``, which can create multiple kernels from different
column of your features array. ``ColumnKernelizer`` works similarly to
``scikit-learn``'s ``ColumnTransformer``, but instead of returning a
concatenation of transformed features, it returns a stack of kernels,
as required in ``MultipleKernelRidgeCV(kernels="precomputed")``.

.. GENERATED FROM PYTHON SOURCE LINES 208-212

First, we create a different ``Kernelizer`` for each feature space.
Here we use a linear kernel for all feature spaces, but ``ColumnKernelizer``
accepts any ``Kernelizer``, or ``scikit-learn`` ``Pipeline`` ending with a
``Kernelizer``.

.. GENERATED FROM PYTHON SOURCE LINES 212-223

.. code-block:: default

    from himalaya.kernel_ridge import Kernelizer
    from sklearn import set_config
    set_config(display='diagram')  # requires scikit-learn 0.23

    preprocess_pipeline = make_pipeline(
        StandardScaler(with_mean=True, with_std=False),
        Delayer(delays=[1, 2, 3, 4]),
        Kernelizer(kernel="linear"),
    )
    preprocess_pipeline






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <style>#sk-container-id-5 {color: black;background-color: white;}#sk-container-id-5 pre{padding: 0;}#sk-container-id-5 div.sk-toggleable {background-color: white;}#sk-container-id-5 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-5 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-5 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-5 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-5 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-5 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-5 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-5 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-5 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-5 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-5 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-5 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-5 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-5 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-5 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-5 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-5 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-5 div.sk-item {position: relative;z-index: 1;}#sk-container-id-5 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-5 div.sk-item::before, #sk-container-id-5 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-5 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-5 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-5 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-5 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-5 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-5 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-5 div.sk-label-container {text-align: center;}#sk-container-id-5 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-5 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-5" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>Pipeline(steps=[(&#x27;standardscaler&#x27;, StandardScaler(with_std=False)),
                    (&#x27;delayer&#x27;, Delayer(delays=[1, 2, 3, 4])),
                    (&#x27;kernelizer&#x27;, Kernelizer())])</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item sk-dashed-wrapped"><div class="sk-label-container"><div class="sk-label sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-16" type="checkbox" ><label for="sk-estimator-id-16" class="sk-toggleable__label sk-toggleable__label-arrow">Pipeline</label><div class="sk-toggleable__content"><pre>Pipeline(steps=[(&#x27;standardscaler&#x27;, StandardScaler(with_std=False)),
                    (&#x27;delayer&#x27;, Delayer(delays=[1, 2, 3, 4])),
                    (&#x27;kernelizer&#x27;, Kernelizer())])</pre></div></div></div><div class="sk-serial"><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-17" type="checkbox" ><label for="sk-estimator-id-17" class="sk-toggleable__label sk-toggleable__label-arrow">StandardScaler</label><div class="sk-toggleable__content"><pre>StandardScaler(with_std=False)</pre></div></div></div><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-18" type="checkbox" ><label for="sk-estimator-id-18" class="sk-toggleable__label sk-toggleable__label-arrow">Delayer</label><div class="sk-toggleable__content"><pre>Delayer(delays=[1, 2, 3, 4])</pre></div></div></div><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-19" type="checkbox" ><label for="sk-estimator-id-19" class="sk-toggleable__label sk-toggleable__label-arrow">Kernelizer</label><div class="sk-toggleable__content"><pre>Kernelizer()</pre></div></div></div></div></div></div></div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 224-226

The column kernelizer applies a different pipeline on each selection of
features, here defined with ``slices``.

.. GENERATED FROM PYTHON SOURCE LINES 226-236

.. code-block:: default

    from himalaya.kernel_ridge import ColumnKernelizer

    # Find the start and end of each feature space in the concatenated ``X_train``.
    start_and_end = np.concatenate([[0], np.cumsum(n_features_list)])
    slices = [
        slice(start, end)
        for start, end in zip(start_and_end[:-1], start_and_end[1:])
    ]
    slices





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    [slice(0, 1705, None), slice(1705, 8260, None)]



.. GENERATED FROM PYTHON SOURCE LINES 237-245

.. code-block:: default

    kernelizers_tuples = [(name, preprocess_pipeline, slice_)
                          for name, slice_ in zip(feature_names, slices)]
    column_kernelizer = ColumnKernelizer(kernelizers_tuples)
    column_kernelizer

    # (Note that ``ColumnKernelizer`` has a parameter ``n_jobs`` to parallelize
    # each ``Kernelizer``, yet such parallelism does not work with GPU arrays.)






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <style>#sk-container-id-6 {color: black;background-color: white;}#sk-container-id-6 pre{padding: 0;}#sk-container-id-6 div.sk-toggleable {background-color: white;}#sk-container-id-6 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-6 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-6 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-6 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-6 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-6 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-6 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-6 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-6 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-6 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-6 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-6 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-6 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-6 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-6 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-6 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-6 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-6 div.sk-item {position: relative;z-index: 1;}#sk-container-id-6 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-6 div.sk-item::before, #sk-container-id-6 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-6 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-6 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-6 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-6 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-6 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-6 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-6 div.sk-label-container {text-align: center;}#sk-container-id-6 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-6 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-6" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>ColumnKernelizer(transformers=[(&#x27;wordnet&#x27;,
                                    Pipeline(steps=[(&#x27;standardscaler&#x27;,
                                                     StandardScaler(with_std=False)),
                                                    (&#x27;delayer&#x27;,
                                                     Delayer(delays=[1, 2, 3, 4])),
                                                    (&#x27;kernelizer&#x27;, Kernelizer())]),
                                    slice(0, 1705, None)),
                                   (&#x27;motion_energy&#x27;,
                                    Pipeline(steps=[(&#x27;standardscaler&#x27;,
                                                     StandardScaler(with_std=False)),
                                                    (&#x27;delayer&#x27;,
                                                     Delayer(delays=[1, 2, 3, 4])),
                                                    (&#x27;kernelizer&#x27;, Kernelizer())]),
                                    slice(1705, 8260, None))])</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item sk-dashed-wrapped"><div class="sk-label-container"><div class="sk-label sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-20" type="checkbox" ><label for="sk-estimator-id-20" class="sk-toggleable__label sk-toggleable__label-arrow">ColumnKernelizer</label><div class="sk-toggleable__content"><pre>ColumnKernelizer(transformers=[(&#x27;wordnet&#x27;,
                                    Pipeline(steps=[(&#x27;standardscaler&#x27;,
                                                     StandardScaler(with_std=False)),
                                                    (&#x27;delayer&#x27;,
                                                     Delayer(delays=[1, 2, 3, 4])),
                                                    (&#x27;kernelizer&#x27;, Kernelizer())]),
                                    slice(0, 1705, None)),
                                   (&#x27;motion_energy&#x27;,
                                    Pipeline(steps=[(&#x27;standardscaler&#x27;,
                                                     StandardScaler(with_std=False)),
                                                    (&#x27;delayer&#x27;,
                                                     Delayer(delays=[1, 2, 3, 4])),
                                                    (&#x27;kernelizer&#x27;, Kernelizer())]),
                                    slice(1705, 8260, None))])</pre></div></div></div><div class="sk-parallel"><div class="sk-parallel-item"><div class="sk-item"><div class="sk-label-container"><div class="sk-label sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-21" type="checkbox" ><label for="sk-estimator-id-21" class="sk-toggleable__label sk-toggleable__label-arrow">wordnet</label><div class="sk-toggleable__content"><pre>slice(0, 1705, None)</pre></div></div></div><div class="sk-serial"><div class="sk-item"><div class="sk-serial"><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-22" type="checkbox" ><label for="sk-estimator-id-22" class="sk-toggleable__label sk-toggleable__label-arrow">StandardScaler</label><div class="sk-toggleable__content"><pre>StandardScaler(with_std=False)</pre></div></div></div><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-23" type="checkbox" ><label for="sk-estimator-id-23" class="sk-toggleable__label sk-toggleable__label-arrow">Delayer</label><div class="sk-toggleable__content"><pre>Delayer(delays=[1, 2, 3, 4])</pre></div></div></div><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-24" type="checkbox" ><label for="sk-estimator-id-24" class="sk-toggleable__label sk-toggleable__label-arrow">Kernelizer</label><div class="sk-toggleable__content"><pre>Kernelizer()</pre></div></div></div></div></div></div></div></div><div class="sk-parallel-item"><div class="sk-item"><div class="sk-label-container"><div class="sk-label sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-25" type="checkbox" ><label for="sk-estimator-id-25" class="sk-toggleable__label sk-toggleable__label-arrow">motion_energy</label><div class="sk-toggleable__content"><pre>slice(1705, 8260, None)</pre></div></div></div><div class="sk-serial"><div class="sk-item"><div class="sk-serial"><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-26" type="checkbox" ><label for="sk-estimator-id-26" class="sk-toggleable__label sk-toggleable__label-arrow">StandardScaler</label><div class="sk-toggleable__content"><pre>StandardScaler(with_std=False)</pre></div></div></div><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-27" type="checkbox" ><label for="sk-estimator-id-27" class="sk-toggleable__label sk-toggleable__label-arrow">Delayer</label><div class="sk-toggleable__content"><pre>Delayer(delays=[1, 2, 3, 4])</pre></div></div></div><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-28" type="checkbox" ><label for="sk-estimator-id-28" class="sk-toggleable__label sk-toggleable__label-arrow">Kernelizer</label><div class="sk-toggleable__content"><pre>Kernelizer()</pre></div></div></div></div></div></div></div></div></div></div></div></div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 246-247

Then we can define the model pipeline.

.. GENERATED FROM PYTHON SOURCE LINES 247-254

.. code-block:: default


    pipeline = make_pipeline(
        column_kernelizer,
        mkr_model,
    )
    pipeline






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <style>#sk-container-id-7 {color: black;background-color: white;}#sk-container-id-7 pre{padding: 0;}#sk-container-id-7 div.sk-toggleable {background-color: white;}#sk-container-id-7 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-7 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-7 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-7 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-7 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-7 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-7 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-7 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-7 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-7 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-7 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-7 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-7 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-7 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-7 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-7 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-7 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-7 div.sk-item {position: relative;z-index: 1;}#sk-container-id-7 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-7 div.sk-item::before, #sk-container-id-7 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-7 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-7 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-7 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-7 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-7 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-7 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-7 div.sk-label-container {text-align: center;}#sk-container-id-7 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-7 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-7" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>Pipeline(steps=[(&#x27;columnkernelizer&#x27;,
                     ColumnKernelizer(transformers=[(&#x27;wordnet&#x27;,
                                                     Pipeline(steps=[(&#x27;standardscaler&#x27;,
                                                                      StandardScaler(with_std=False)),
                                                                     (&#x27;delayer&#x27;,
                                                                      Delayer(delays=[1,
                                                                                      2,
                                                                                      3,
                                                                                      4])),
                                                                     (&#x27;kernelizer&#x27;,
                                                                      Kernelizer())]),
                                                     slice(0, 1705, None)),
                                                    (&#x27;motion_energy&#x27;,
                                                     Pipeline(steps=[(&#x27;standardscaler&#x27;,
                                                                      StandardScaler(with_std=False)),
                                                                     (&#x27;delayer&#x27;,
                                                                      Delayer(delays=[1,
                                                                                      2,
                                                                                      3,
                                                                                      4]...
                     MultipleKernelRidgeCV(cv=_CVIterableWrapper(cv=[(array([   0,    1, ..., 3598, 3599]), array([1800, 1801, ..., 2098, 2099])), (array([   0,    1, ..., 3598, 3599]), array([2400, 2401, ..., 2698, 2699])), (array([   0,    1, ..., 3598, 3599]), array([2700, 2701, ..., 2998, 2999])), (array([ 300,  301, ..., 3598, 3599]), array([  0,   1, ..., 2... 3001, ..., 3298, 3299])), (array([   0,    1, ..., 3598, 3599]), array([300, 301, ..., 598, 599]))]),
                                           kernels=&#x27;precomputed&#x27;,
                                           solver_params={&#x27;alphas&#x27;: array([1.e+01, 1.e+02, 1.e+03, 1.e+04, 1.e+05, 1.e+06, 1.e+07, 1.e+08,
           1.e+09, 1.e+10, 1.e+11, 1.e+12, 1.e+13, 1.e+14, 1.e+15, 1.e+16,
           1.e+17, 1.e+18, 1.e+19, 1.e+20]),
                                                          &#x27;n_alphas_batch&#x27;: 5,
                                                          &#x27;n_iter&#x27;: 20,
                                                          &#x27;n_targets_batch&#x27;: 200,
                                                          &#x27;n_targets_batch_refit&#x27;: 200}))])</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item sk-dashed-wrapped"><div class="sk-label-container"><div class="sk-label sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-29" type="checkbox" ><label for="sk-estimator-id-29" class="sk-toggleable__label sk-toggleable__label-arrow">Pipeline</label><div class="sk-toggleable__content"><pre>Pipeline(steps=[(&#x27;columnkernelizer&#x27;,
                     ColumnKernelizer(transformers=[(&#x27;wordnet&#x27;,
                                                     Pipeline(steps=[(&#x27;standardscaler&#x27;,
                                                                      StandardScaler(with_std=False)),
                                                                     (&#x27;delayer&#x27;,
                                                                      Delayer(delays=[1,
                                                                                      2,
                                                                                      3,
                                                                                      4])),
                                                                     (&#x27;kernelizer&#x27;,
                                                                      Kernelizer())]),
                                                     slice(0, 1705, None)),
                                                    (&#x27;motion_energy&#x27;,
                                                     Pipeline(steps=[(&#x27;standardscaler&#x27;,
                                                                      StandardScaler(with_std=False)),
                                                                     (&#x27;delayer&#x27;,
                                                                      Delayer(delays=[1,
                                                                                      2,
                                                                                      3,
                                                                                      4]...
                     MultipleKernelRidgeCV(cv=_CVIterableWrapper(cv=[(array([   0,    1, ..., 3598, 3599]), array([1800, 1801, ..., 2098, 2099])), (array([   0,    1, ..., 3598, 3599]), array([2400, 2401, ..., 2698, 2699])), (array([   0,    1, ..., 3598, 3599]), array([2700, 2701, ..., 2998, 2999])), (array([ 300,  301, ..., 3598, 3599]), array([  0,   1, ..., 2... 3001, ..., 3298, 3299])), (array([   0,    1, ..., 3598, 3599]), array([300, 301, ..., 598, 599]))]),
                                           kernels=&#x27;precomputed&#x27;,
                                           solver_params={&#x27;alphas&#x27;: array([1.e+01, 1.e+02, 1.e+03, 1.e+04, 1.e+05, 1.e+06, 1.e+07, 1.e+08,
           1.e+09, 1.e+10, 1.e+11, 1.e+12, 1.e+13, 1.e+14, 1.e+15, 1.e+16,
           1.e+17, 1.e+18, 1.e+19, 1.e+20]),
                                                          &#x27;n_alphas_batch&#x27;: 5,
                                                          &#x27;n_iter&#x27;: 20,
                                                          &#x27;n_targets_batch&#x27;: 200,
                                                          &#x27;n_targets_batch_refit&#x27;: 200}))])</pre></div></div></div><div class="sk-serial"><div class="sk-item sk-dashed-wrapped"><div class="sk-label-container"><div class="sk-label sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-30" type="checkbox" ><label for="sk-estimator-id-30" class="sk-toggleable__label sk-toggleable__label-arrow">columnkernelizer: ColumnKernelizer</label><div class="sk-toggleable__content"><pre>ColumnKernelizer(transformers=[(&#x27;wordnet&#x27;,
                                    Pipeline(steps=[(&#x27;standardscaler&#x27;,
                                                     StandardScaler(with_std=False)),
                                                    (&#x27;delayer&#x27;,
                                                     Delayer(delays=[1, 2, 3, 4])),
                                                    (&#x27;kernelizer&#x27;, Kernelizer())]),
                                    slice(0, 1705, None)),
                                   (&#x27;motion_energy&#x27;,
                                    Pipeline(steps=[(&#x27;standardscaler&#x27;,
                                                     StandardScaler(with_std=False)),
                                                    (&#x27;delayer&#x27;,
                                                     Delayer(delays=[1, 2, 3, 4])),
                                                    (&#x27;kernelizer&#x27;, Kernelizer())]),
                                    slice(1705, 8260, None))])</pre></div></div></div><div class="sk-parallel"><div class="sk-parallel-item"><div class="sk-item"><div class="sk-label-container"><div class="sk-label sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-31" type="checkbox" ><label for="sk-estimator-id-31" class="sk-toggleable__label sk-toggleable__label-arrow">wordnet</label><div class="sk-toggleable__content"><pre>slice(0, 1705, None)</pre></div></div></div><div class="sk-serial"><div class="sk-item"><div class="sk-serial"><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-32" type="checkbox" ><label for="sk-estimator-id-32" class="sk-toggleable__label sk-toggleable__label-arrow">StandardScaler</label><div class="sk-toggleable__content"><pre>StandardScaler(with_std=False)</pre></div></div></div><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-33" type="checkbox" ><label for="sk-estimator-id-33" class="sk-toggleable__label sk-toggleable__label-arrow">Delayer</label><div class="sk-toggleable__content"><pre>Delayer(delays=[1, 2, 3, 4])</pre></div></div></div><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-34" type="checkbox" ><label for="sk-estimator-id-34" class="sk-toggleable__label sk-toggleable__label-arrow">Kernelizer</label><div class="sk-toggleable__content"><pre>Kernelizer()</pre></div></div></div></div></div></div></div></div><div class="sk-parallel-item"><div class="sk-item"><div class="sk-label-container"><div class="sk-label sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-35" type="checkbox" ><label for="sk-estimator-id-35" class="sk-toggleable__label sk-toggleable__label-arrow">motion_energy</label><div class="sk-toggleable__content"><pre>slice(1705, 8260, None)</pre></div></div></div><div class="sk-serial"><div class="sk-item"><div class="sk-serial"><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-36" type="checkbox" ><label for="sk-estimator-id-36" class="sk-toggleable__label sk-toggleable__label-arrow">StandardScaler</label><div class="sk-toggleable__content"><pre>StandardScaler(with_std=False)</pre></div></div></div><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-37" type="checkbox" ><label for="sk-estimator-id-37" class="sk-toggleable__label sk-toggleable__label-arrow">Delayer</label><div class="sk-toggleable__content"><pre>Delayer(delays=[1, 2, 3, 4])</pre></div></div></div><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-38" type="checkbox" ><label for="sk-estimator-id-38" class="sk-toggleable__label sk-toggleable__label-arrow">Kernelizer</label><div class="sk-toggleable__content"><pre>Kernelizer()</pre></div></div></div></div></div></div></div></div></div></div><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-39" type="checkbox" ><label for="sk-estimator-id-39" class="sk-toggleable__label sk-toggleable__label-arrow">MultipleKernelRidgeCV</label><div class="sk-toggleable__content"><pre>MultipleKernelRidgeCV(cv=_CVIterableWrapper(cv=[(array([   0,    1, ..., 3598, 3599]), array([1800, 1801, ..., 2098, 2099])), (array([   0,    1, ..., 3598, 3599]), array([2400, 2401, ..., 2698, 2699])), (array([   0,    1, ..., 3598, 3599]), array([2700, 2701, ..., 2998, 2999])), (array([ 300,  301, ..., 3598, 3599]), array([  0,   1, ..., 2... 3001, ..., 3298, 3299])), (array([   0,    1, ..., 3598, 3599]), array([300, 301, ..., 598, 599]))]),
                          kernels=&#x27;precomputed&#x27;,
                          solver_params={&#x27;alphas&#x27;: array([1.e+01, 1.e+02, 1.e+03, 1.e+04, 1.e+05, 1.e+06, 1.e+07, 1.e+08,
           1.e+09, 1.e+10, 1.e+11, 1.e+12, 1.e+13, 1.e+14, 1.e+15, 1.e+16,
           1.e+17, 1.e+18, 1.e+19, 1.e+20]),
                                         &#x27;n_alphas_batch&#x27;: 5, &#x27;n_iter&#x27;: 20,
                                         &#x27;n_targets_batch&#x27;: 200,
                                         &#x27;n_targets_batch_refit&#x27;: 200})</pre></div></div></div></div></div></div></div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 255-265

Fit the model
-------------

We fit on the train set, and score on the test set.

To speed up the fit and to limit the memory peak in Colab, we only fit on
voxels with explainable variance above 0.1.

With a GPU backend, the fitting of this model takes around 6 minutes. With a
CPU backend, it can last 10 times more.

.. GENERATED FROM PYTHON SOURCE LINES 265-279

.. code-block:: default


    pipeline.fit(X_train, Y_train[:, mask])

    scores_mask = pipeline.score(X_test, Y_test[:, mask])
    scores_mask = backend.to_numpy(scores_mask)
    print("(n_voxels_mask,) =", scores_mask.shape)

    # Then we extend the scores to all voxels, giving a score of zero to unfitted
    # voxels.
    n_voxels = Y_train.shape[1]
    scores = np.zeros(n_voxels)
    scores[mask] = scores_mask
    print("(n_voxels,) =", scores.shape)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [                                        ] 0% | 0.00 sec | 20 random sampling with cv |     [..                                      ] 5% | 7.12 sec | 20 random sampling with cv |     [....                                    ] 10% | 14.11 sec | 20 random sampling with cv |     [......                                  ] 15% | 21.39 sec | 20 random sampling with cv |     [........                                ] 20% | 28.50 sec | 20 random sampling with cv |     [..........                              ] 25% | 35.46 sec | 20 random sampling with cv |     [............                            ] 30% | 42.64 sec | 20 random sampling with cv |     [..............                          ] 35% | 49.14 sec | 20 random sampling with cv |     [................                        ] 40% | 56.23 sec | 20 random sampling with cv |     [..................                      ] 45% | 63.39 sec | 20 random sampling with cv |     [....................                    ] 50% | 70.13 sec | 20 random sampling with cv |     [......................                  ] 55% | 77.33 sec | 20 random sampling with cv |     [........................                ] 60% | 84.40 sec | 20 random sampling with cv |     [..........................              ] 65% | 91.32 sec | 20 random sampling with cv |     [............................            ] 70% | 98.30 sec | 20 random sampling with cv |     [..............................          ] 75% | 105.32 sec | 20 random sampling with cv |     [................................        ] 80% | 112.51 sec | 20 random sampling with cv |     [..................................      ] 85% | 119.30 sec | 20 random sampling with cv |     [....................................    ] 90% | 126.31 sec | 20 random sampling with cv |     [......................................  ] 95% | 133.39 sec | 20 random sampling with cv |     [........................................] 100% | 140.22 sec | 20 random sampling with cv | 
    (n_voxels_mask,) = (6849,)
    (n_voxels,) = (84038,)




.. GENERATED FROM PYTHON SOURCE LINES 280-286

Compare with a ridge model
--------------------------

We can compare with a baseline model, which does not use one hyperparameter
per feature space, but instead shares the same hyperparameter for all feature
spaces.

.. GENERATED FROM PYTHON SOURCE LINES 286-300

.. code-block:: default


    from himalaya.kernel_ridge import KernelRidgeCV

    pipeline_baseline = make_pipeline(
        StandardScaler(with_mean=True, with_std=False),
        Delayer(delays=[1, 2, 3, 4]),
        KernelRidgeCV(
            alphas=alphas, cv=cv,
            solver_params=dict(n_targets_batch=n_targets_batch,
                               n_alphas_batch=n_alphas_batch,
                               n_targets_batch_refit=n_targets_batch_refit)),
    )
    pipeline_baseline






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <style>#sk-container-id-8 {color: black;background-color: white;}#sk-container-id-8 pre{padding: 0;}#sk-container-id-8 div.sk-toggleable {background-color: white;}#sk-container-id-8 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-8 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-8 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-8 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-8 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-8 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-8 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-8 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-8 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-8 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-8 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-8 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-8 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-8 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-8 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-8 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-8 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-8 div.sk-item {position: relative;z-index: 1;}#sk-container-id-8 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-8 div.sk-item::before, #sk-container-id-8 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-8 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-8 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-8 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-8 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-8 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-8 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-8 div.sk-label-container {text-align: center;}#sk-container-id-8 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-8 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-8" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>Pipeline(steps=[(&#x27;standardscaler&#x27;, StandardScaler(with_std=False)),
                    (&#x27;delayer&#x27;, Delayer(delays=[1, 2, 3, 4])),
                    (&#x27;kernelridgecv&#x27;,
                     KernelRidgeCV(alphas=array([1.e+01, 1.e+02, 1.e+03, 1.e+04, 1.e+05, 1.e+06, 1.e+07, 1.e+08,
           1.e+09, 1.e+10, 1.e+11, 1.e+12, 1.e+13, 1.e+14, 1.e+15, 1.e+16,
           1.e+17, 1.e+18, 1.e+19, 1.e+20]),
                                   cv=_CVIterableWrapper(cv=[(array([   0,    1, ..., 3598, 3599]), array...9])), (array([   0,    1, ..., 3598, 3599]), array([2400, 2401, ..., 2698, 2699])), (array([   0,    1, ..., 3598, 3599]), array([2700, 2701, ..., 2998, 2999])), (array([ 300,  301, ..., 3598, 3599]), array([  0,   1, ..., 2... 3001, ..., 3298, 3299])), (array([   0,    1, ..., 3598, 3599]), array([300, 301, ..., 598, 599]))]),
                                   solver_params={&#x27;n_alphas_batch&#x27;: 5,
                                                  &#x27;n_targets_batch&#x27;: 200,
                                                  &#x27;n_targets_batch_refit&#x27;: 200}))])</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item sk-dashed-wrapped"><div class="sk-label-container"><div class="sk-label sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-40" type="checkbox" ><label for="sk-estimator-id-40" class="sk-toggleable__label sk-toggleable__label-arrow">Pipeline</label><div class="sk-toggleable__content"><pre>Pipeline(steps=[(&#x27;standardscaler&#x27;, StandardScaler(with_std=False)),
                    (&#x27;delayer&#x27;, Delayer(delays=[1, 2, 3, 4])),
                    (&#x27;kernelridgecv&#x27;,
                     KernelRidgeCV(alphas=array([1.e+01, 1.e+02, 1.e+03, 1.e+04, 1.e+05, 1.e+06, 1.e+07, 1.e+08,
           1.e+09, 1.e+10, 1.e+11, 1.e+12, 1.e+13, 1.e+14, 1.e+15, 1.e+16,
           1.e+17, 1.e+18, 1.e+19, 1.e+20]),
                                   cv=_CVIterableWrapper(cv=[(array([   0,    1, ..., 3598, 3599]), array...9])), (array([   0,    1, ..., 3598, 3599]), array([2400, 2401, ..., 2698, 2699])), (array([   0,    1, ..., 3598, 3599]), array([2700, 2701, ..., 2998, 2999])), (array([ 300,  301, ..., 3598, 3599]), array([  0,   1, ..., 2... 3001, ..., 3298, 3299])), (array([   0,    1, ..., 3598, 3599]), array([300, 301, ..., 598, 599]))]),
                                   solver_params={&#x27;n_alphas_batch&#x27;: 5,
                                                  &#x27;n_targets_batch&#x27;: 200,
                                                  &#x27;n_targets_batch_refit&#x27;: 200}))])</pre></div></div></div><div class="sk-serial"><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-41" type="checkbox" ><label for="sk-estimator-id-41" class="sk-toggleable__label sk-toggleable__label-arrow">StandardScaler</label><div class="sk-toggleable__content"><pre>StandardScaler(with_std=False)</pre></div></div></div><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-42" type="checkbox" ><label for="sk-estimator-id-42" class="sk-toggleable__label sk-toggleable__label-arrow">Delayer</label><div class="sk-toggleable__content"><pre>Delayer(delays=[1, 2, 3, 4])</pre></div></div></div><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-43" type="checkbox" ><label for="sk-estimator-id-43" class="sk-toggleable__label sk-toggleable__label-arrow">KernelRidgeCV</label><div class="sk-toggleable__content"><pre>KernelRidgeCV(alphas=array([1.e+01, 1.e+02, 1.e+03, 1.e+04, 1.e+05, 1.e+06, 1.e+07, 1.e+08,
           1.e+09, 1.e+10, 1.e+11, 1.e+12, 1.e+13, 1.e+14, 1.e+15, 1.e+16,
           1.e+17, 1.e+18, 1.e+19, 1.e+20]),
                  cv=_CVIterableWrapper(cv=[(array([   0,    1, ..., 3598, 3599]), array([1800, 1801, ..., 2098, 2099])), (array([   0,    1, ..., 3598, 3599]), array([2400, 2401, ..., 2698, 2699])), (array([   0,    1, ..., 3598, 3599]), array([2700, 2701, ..., 2998, 2999])), (array([ 300,  301, ..., 3598, 3599]), array([  0,   1, ..., 2... 3001, ..., 3298, 3299])), (array([   0,    1, ..., 3598, 3599]), array([300, 301, ..., 598, 599]))]),
                  solver_params={&#x27;n_alphas_batch&#x27;: 5, &#x27;n_targets_batch&#x27;: 200,
                                 &#x27;n_targets_batch_refit&#x27;: 200})</pre></div></div></div></div></div></div></div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 301-310

.. code-block:: default

    pipeline_baseline.fit(X_train, Y_train[:, mask])
    scores_baseline_mask = pipeline_baseline.score(X_test, Y_test[:, mask])
    scores_baseline_mask = backend.to_numpy(scores_baseline_mask)

    # extend to unfitted voxels
    n_voxels = Y_train.shape[1]
    scores_baseline = np.zeros(n_voxels)
    scores_baseline[mask] = scores_baseline_mask








.. GENERATED FROM PYTHON SOURCE LINES 311-316

Here we plot the comparison of model prediction accuracies with a 2D
histogram. All 70k voxels are represented in this histogram, where the
diagonal corresponds to identical model prediction accuracy for both models.
A distibution deviating from the diagonal means that one model has better
predictive performance than the other.

.. GENERATED FROM PYTHON SOURCE LINES 316-324

.. code-block:: default

    import matplotlib.pyplot as plt
    from voxelwise_tutorials.viz import plot_hist2d

    ax = plot_hist2d(scores_baseline, scores)
    ax.set(title='Generalization R2 scores', xlabel='KernelRidgeCV',
           ylabel='MultipleKernelRidgeCV')
    plt.show()




.. image-sg:: /_auto_examples/shortclips/images/sphx_glr_06_plot_banded_ridge_model_001.png
   :alt: Generalization R2 scores
   :srcset: /_auto_examples/shortclips/images/sphx_glr_06_plot_banded_ridge_model_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 325-331

We see that the banded ridge model (``MultipleKernelRidgeCV``) outperforms
the ridge model (``KernelRidegeCV``). Indeed, banded ridge regression is able
to find the optimal scalings of each feature space, independently on each
voxel. Banded ridge regression is thus able to perform a soft selection
between the available feature spaces, based on the cross-validation
performances.

.. GENERATED FROM PYTHON SOURCE LINES 333-349

Plot the banded ridge split
---------------------------

On top of better prediction accuracy, banded ridge regression also gives a
way to disentangle the contribution of the two feature spaces. To do so, we
take the kernel weights and the ridge (dual) weights corresponding to each
feature space, and use them to compute the prediction from each feature space
separately.

.. math::

      \hat{y} = \sum_i^m \hat{y}_i = \sum_i^m \gamma_i K_i \hat{w}

Then, we use these split predictions to compute split :math:`\tilde{R}^2_i`
scores. These scores are corrected so that their sum is equal to the
:math:`R^2` score of the full prediction :math:`\hat{y}`.

.. GENERATED FROM PYTHON SOURCE LINES 349-365

.. code-block:: default


    from himalaya.scoring import r2_score_split

    Y_test_pred_split = pipeline.predict(X_test, split=True)
    split_scores_mask = r2_score_split(Y_test[:, mask], Y_test_pred_split)

    print("(n_kernels, n_samples_test, n_voxels_mask) =", Y_test_pred_split.shape)
    print("(n_kernels, n_voxels_mask) =", split_scores_mask.shape)

    # extend to unfitted voxels
    n_kernels = split_scores_mask.shape[0]
    n_voxels = Y_train.shape[1]
    split_scores = np.zeros((n_kernels, n_voxels))
    split_scores[:, mask] = backend.to_numpy(split_scores_mask)
    print("(n_kernels, n_voxels) =", split_scores.shape)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (n_kernels, n_samples_test, n_voxels_mask) = torch.Size([2, 270, 6849])
    (n_kernels, n_voxels_mask) = torch.Size([2, 6849])
    (n_kernels, n_voxels) = (2, 84038)




.. GENERATED FROM PYTHON SOURCE LINES 366-367

We can then plot the split scores on a flatmap with a 2D colormap.

.. GENERATED FROM PYTHON SOURCE LINES 367-377

.. code-block:: default


    from voxelwise_tutorials.viz import plot_2d_flatmap_from_mapper

    mapper_file = os.path.join(directory, "mappers", f"{subject}_mappers.hdf")
    ax = plot_2d_flatmap_from_mapper(split_scores[0], split_scores[1],
                                     mapper_file, vmin=0, vmax=0.25, vmin2=0,
                                     vmax2=0.5, label_1=feature_names[0],
                                     label_2=feature_names[1])
    plt.show()




.. image-sg:: /_auto_examples/shortclips/images/sphx_glr_06_plot_banded_ridge_model_002.png
   :alt: 06 plot banded ridge model
   :srcset: /_auto_examples/shortclips/images/sphx_glr_06_plot_banded_ridge_model_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 378-389

The blue regions are better predicted by the motion-energy features, the
orange regions are better predicted by the wordnet features, and the white
regions are well predicted by both feature spaces.

Compared to the last figure of the previous example, we see that most white
regions have been replaced by either blue or orange regions. The banded ridge
regression disentangled the two feature spaces in voxels where both feature
spaces had good prediction accuracy (see previous example). For example,
motion-energy features predict brain activity in early visual cortex, while
wordnet features predict in semantic visual areas. For more discussions about
these results, we refer the reader to the original publication [1]_.

.. GENERATED FROM PYTHON SOURCE LINES 391-397

References
----------

.. [1] Nunez-Elizalde, A. O., Huth, A. G., & Gallant, J. L. (2019).
    Voxelwise encoding models with non-spherical multivariate normal priors.
    Neuroimage, 197, 482-492.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 2 minutes  51.509 seconds)


.. _sphx_glr_download__auto_examples_shortclips_06_plot_banded_ridge_model.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 06_plot_banded_ridge_model.py <06_plot_banded_ridge_model.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 06_plot_banded_ridge_model.ipynb <06_plot_banded_ridge_model.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
